/*
 * client.C
 *
 *  Created on: 11.09.2019
 *      Author: aml
 */

/// @file
/// @brief contains the implementation of the client
#include <string>
#include <sstream>
#include <iostream>
#include <unistd.h> 
#include <chrono>
#include <thread>
#include <fstream>

//contains various constants

#include "SIMPLESOCKET.H"
#include "TASK1.H"

using namespace std;

/// @param oldPassword Previously generated password
/// @param symbSetSize dictates how many different characters from the const string SYMBOLS are being used 
/// @param currenPosition dictates which position of the string is changed 


string nextPassword(string oldPassword, int symbSetSize, int currentPosition);
int main(){
	srand(time(NULL)); 
	TCPclient c; 
	string host = "localhost";
	string msg;
	/// 
	/// @param initPW first possible password string (e.g. AAAA)
	string initPW;
	fstream f;
	/// 
	/// @param counter number of attempts for one password 
	int counter = 0;

	
	//connect to host
	c.conn(host , 2022);

	bool goOn=true;
	f.open("Daten.dat", ios::out);

	while(goOn){ // send and receive data
		string guess;
		int length;
		int size;
		/// 
		/// @param numberOfPW how often a new password should be generated by the server after guessing right
		int numberOfPW;
		///
		/// @param differenPassword counts how many new passwords have been generated
		int differenPassword = 0;

		string pwdLength;
		cin>>guess;
		c.sendData(guess);
		msg = c.receive(32);
		if(guess.compare(0, 7,"newPwd(") == 0)
		{
			std::sscanf(guess.c_str(), "newPwd(%i,%i,%i)", &length, &size, &numberOfPW);
			initPW = std::string(length, TASK1::SYMBOLS[0]);
		}
		f << "Password length: " << length << "Size of variable: " << size << endl;
		//systematically attemptempts to send every possible password
		c.sendData(initPW);
		msg = c.receive(32);							
		while(true)
		{
			initPW = nextPassword(initPW, size, length-1);
			cout<<"clients sends:"<< initPW << endl;
			c.sendData(initPW);
			msg = c.receive(32);
			cout << "got response: " << msg << endl;
			cout << "Try number: " << counter << endl;
			counter ++;
			if(msg.compare(0,15,"ACCESS ACCEPTED") == 0)
			{
				f<< counter-1 << endl;
				ostringstream oss;
				oss << "newPwd(" << length <<"," << size;
				guess = oss.str();
				c.sendData(guess);
				msg = c.receive(32);
				initPW = std::string(length, TASK1::SYMBOLS[0]);
				c.sendData(initPW);
				msg = c.receive(32);
				differenPassword++;
				counter = 1;
				
			}
			if(differenPassword == numberOfPW)
			{
				break;
			}
		}

	}
}
/// @brief systematically generates the next password
/// @return returns a password string 
string nextPassword(string oldPassword, int symbSetSize, int currentPosition)
{
	if(currentPosition < 0) //error handling
	{
		return oldPassword;				//HACK
	}
	char workChar = oldPassword[currentPosition]; // the position in the string where the character is changed  
	if(workChar == TASK1::SYMBOLS[symbSetSize-1]) 		//Overflow -> if the character exceeds the defined characters 
	{
		workChar = TASK1::SYMBOLS[0]; //sets last character to the first letter of the defined alphabet
		oldPassword[currentPosition] = workChar; //sets the workchar to one letter to the left
		return nextPassword(oldPassword, symbSetSize, currentPosition-1); //recursion 
	} 

	int index;
	for(int i = 0; i<TASK1::SYMBOLS.length(); i++)			// error handling so the password does not exceed the defined length
	{
		if(workChar == TASK1::SYMBOLS[i])
		{
			index = i+1;	
			break;	
		}			
	}
	if(index == TASK1::SYMBOLS.length())
	{
		index = index-1;						//HACK
	}
 	oldPassword[currentPosition] = TASK1::SYMBOLS[index]; // to prevent stack overflow instead of infinite recursion the function outputs the same string over and over again
	return oldPassword;
}